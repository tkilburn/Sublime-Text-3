#!/usr/bin/env node

// HTTP server for desktop editors

// Reads .tern-project files, wraps a Tern server in an HTTP wrapper
// so that editor plug-ins can talk to it.

var tern = require("../lib/tern");
var fs = require("fs"), path = require("path"), url = require("url");
var glob = require("glob"), minimatch = require("minimatch");

var projectFileName = ".tern-project", portFileName = ".tern-port";
var maxIdleTime = 6e4 * 5; // Shut down after five minutes of inactivity

var persistent = process.argv.indexOf("--persistent") > -1;
var stripCRs = process.argv.indexOf("--strip-crs") > -1;
var disableLoadingLocal = process.argv.indexOf("--disable-loading-local") > -1;
var verbose = process.argv.indexOf("--verbose") > -1;
var noPortFile = process.argv.indexOf("--no-port-file") > -1;
var host = "127.0.0.1";
var hostArg = process.argv.indexOf("--host");
if (hostArg > -1) {
  host = process.argv[hostArg + 1];
  if (host == "null" || host == "any") host = null;
}
var port = 0;
var portArg = process.argv.indexOf("--port");
if (portArg > -1) {
   port = Number(process.argv[portArg + 1]);
   if (isNaN(port)) port = 0;
}

function findProjectDir() {
  var dir = process.cwd();
  for (;;) {
    try {
      // Slava: search for meteor projects
      if (fs.statSync(path.resolve(dir, ".meteor")).isDirectory()) {
        // Slava: if we found a .meteor folder in our home, it probably means, we
        // found a Meteor installation and not the project. We can check it by this
        // hack: if "packages" is a file, then it is a project.
        if (fs.statSync(path.join(dir, ".meteor", "packages")).isDirectory())
          return null;
        return dir;
      }
      //if (fs.statSync(path.resolve(dir, projectFileName)).isFile()) return dir;
    } catch(e) {}
    try {
      if (fs.statSync(path.resolve(dir, "package.js")).isFile()) {
        // Slava: Also stop if a package.js file is found
        return dir;
      }
    } catch(e) {}
    var shorter = path.dirname(dir);
    if (shorter == dir) return null;
    dir = shorter;
  }
}

var defaultConfig = {
  libs: [],
  loadEagerly: false,
  plugins: {},
  ecmaScript: true,
  dependencyBudget: tern.defaultOptions.dependencyBudget
};
var homeDir = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
if (homeDir && fs.existsSync(path.resolve(homeDir, ".tern-config")))
  defaultConfig = readProjectFile(path.resolve(homeDir, ".tern-config"));

function readJSON(fileName) {
  var file = fs.readFileSync(fileName, "utf8");
  try {
    return JSON.parse(file);
  } catch (e) {
    console.error("Bad JSON in " + fileName + ": " + e.message);
    process.exit(1);
  }
}

function readProjectFile(fileName, type) {
  // Slava: always use the same config for all Meteor apps
  //var data = readJSON(fileName);
  var data = {
    "libs": [
      "browser",
      "jquery",
      "underscore"
    ],
    "loadEagerly": ["**/*.html", "packages/**/*.js", "**/*.js"],
    "dontLoad": [ "**/.git/**", "**/.hg/**", "**/.svn/**" ],
    "plugins": {
      "meteor": {},
      "node": {}
    }
  };
  // Slava: for client part and server part have different conf
  if (type === 'client') {
    delete data.plugins.node;
  }
  if (type === 'server') {
    data.libs = ['underscore'];
  }

  for (var option in defaultConfig) if (!data.hasOwnProperty(option))
    data[option] = defaultConfig[option];
  return data;
}

function findFile(file, projectDir, fallbackDir) {
  var local = path.resolve(projectDir, file);
  if (!disableLoadingLocal && fs.existsSync(local)) return local;
  var shared = path.resolve(fallbackDir, file);
  if (fs.existsSync(shared)) return shared;
}

var distDir = path.resolve(__dirname, "..");

function findDefs(projectDir, config) {
  var defs = [], src = config.libs;
  if (src.indexOf("ecma5") == -1 && config.ecmaScript) src = ["ecma5"].concat(src);
  for (var i = 0; i < src.length; ++i) {
    var file = src[i];
    if (!/\.json$/.test(file)) file = file + ".json";
    var found = findFile(file, projectDir, path.resolve(distDir, "defs"));
    if (found) defs.push(readJSON(found));
    else process.stderr.write("Failed to find library " + src[i] + ".\n");
  }
  return defs;
}

var defaultPlugins = ["doc_comment"];

function loadPlugins(projectDir, plugins) {
  var options = {};
  for (var plugin in plugins) {
    var val = plugins[plugin];
    if (!val) continue;
    var found = findFile(plugin + ".js", projectDir, path.resolve(distDir, "plugin"));
    if (!found) {
      try {
        found = require.resolve("tern-" + plugin);
      } catch (e) {
        process.stderr.write("Failed to find plugin " + plugin + ".\n");
        continue;
      }
    }
    var mod = require(found);
    if (mod.hasOwnProperty("initialize")) mod.initialize(distDir);
    options[path.basename(plugin)] = val;
  }

  defaultPlugins.forEach(function(name) {
    if (!plugins.hasOwnProperty(name)) {
      options[name] = true;
      require("../plugin/" + name);
    }
  });
  return options;
}

// Slava: load Meteor packages in a built form (isopacks)
function loadPackages(dir, arch, server) {
  var dotMeteor = path.join(dir, '.meteor');
  var home = process.env.HOME;
  if (process.platform === 'win32') {
    home = process.env.LOCALAPPDATA;
  }
  var warehouse = path.join(home, '.meteor');
  if (! fs.existsSync(path.join(dotMeteor, 'versions'))) return;
  var versionsRaw = fs.readFileSync(path.join(dotMeteor, 'versions'), 'utf8');
  var versions = versionsRaw
    .split('\n')
    .filter(function (s) { return s.trim().length > 0 && s[0] !== '#'; })
    .map(function (s) { return s.split('@'); })
    .filter(function (s) { return !isCorePackage(s[0]); });

  versions.forEach(function (pkg) {
    var p = pkg[0];
    var v = pkg[1];
    [true, false].forEach(function (doEsc) {
      [true, false].forEach(function (doEsc2) {
        var pp = doEsc ? esc(p) : p;
        var ppp = doEsc2 ? esc(p) : p;
        tryLoad(path.join(dotMeteor, 'local', 'isopacks', pp, arch, 'packages', ppp + '.js'), server);
        tryLoad(path.join(warehouse, 'packages', pp, v, arch, 'packages', ppp + '.js'), server);
      });
    });
  });

  setTimeout(checkVersions, 2 * 1000); // every 2 secs

  function esc(s) { return s.replace(/:/g, '_'); }
  function tryLoad(p, server) {
    if (! fs.existsSync(p)) return;
    server.addFile(p);
  }
  function isCorePackage(p) {
    return ['accounts-base', 'accounts-facebook', 'accounts-github', 'accounts-google', 'accounts-meetup', 'accounts-meteor-developer', 'accounts-oauth', 'accounts-password', 'accounts-twitter', 'accounts-ui', 'accounts-ui-unstyled', 'accounts-weibo', 'appcache', 'audit-argument-checks', 'autopublish', 'autoupdate', 'base64', 'binary-heap', 'blaze', 'blaze-tools', 'boilerplate-generator', 'browser-policy', 'browser-policy-common', 'browser-policy-content', 'browser-policy-framing', 'callback-hook', 'check', 'code-prettify', 'coffeescript', 'coffeescript-test-helper', 'constraint-solver', 'ddp', 'deprecated', 'deps', 'disable-oplog', 'ejson', 'email', 'facebook', 'facts', 'fastclick', 'force-ssl', 'geojson-utils', 'github', 'google', 'handlebars', 'html-tools', 'htmljs', 'http', 'id-map', 'insecure', 'jquery', 'jquery-waypoints', 'js-analyze', 'js-analyze-tests', 'json', 'jsparse', 'launch-screen', 'less', 'livedata', 'localstorage', 'logging', 'logic-solver', 'markdown', 'meetup', 'meteor', 'meteor-developer', 'meteor-platform', 'meteor-tool', 'meyerweb-reset', 'minifiers', 'minimongo', 'mobile-status-bar', 'mongo', 'mongo-livedata', 'non-core', 'oauth', 'oauth-encryption', 'oauth1', 'oauth2', 'observe-sequence', 'ordered-dict', 'package-stats-opt-out', 'package-version-parser', 'preserve-inputs', 'random', 'reactive-dict', 'reactive-var', 'reload', 'reload-safetybelt', 'retry', 'routepolicy', 'service-configuration', 'session', 'sha', 'showdown', 'spacebars', 'spacebars-compiler', 'spacebars-tests', 'spiderable', 'srp', 'standard-app-packages', 'startup', 'stylus', 'templating', 'test-helpers', 'test-in-browser', 'test-in-console', 'test-server-tests-in-console-once', 'tinytest', 'tracker', 'twitter', 'ui', 'underscore', 'underscore-tests', 'url', 'webapp', 'webapp-hashing', 'weibo', 'xmlbuilder'].indexOf(p) !== -1;
  }
  function checkVersions() {
    console.log('checking')
    var newRaw = fs.readFileSync(path.join(dotMeteor, 'versions'), 'utf8');
    if (newRaw !== versionsRaw) {
      console.log('NEW VERSIONS');
      setTimeout(function () {
        loadPackages(dir, arch, server);
      }, 5 * 1000); // give 5 secs for rebuilds
    } else {
      setTimeout(checkVersions, 2 * 1000);
    }
  }
};

var projectDir = findProjectDir();
if (projectDir) {
  var clientConfig = readProjectFile(path.resolve(projectDir, projectFileName), 'client');
  var serverConfig = readProjectFile(path.resolve(projectDir, projectFileName), 'server');
} else {
  projectDir = process.cwd();
  // Slava: if we are not in a Meteor project, don't try to load anything,
  // really
  var config = readProjectFile();
  var clientConfig = config;
  var serverConfig = config;
  config.loadEagerly = [];
  // var config = defaultConfig;
}
// Slava:
// Create two infering servers, for Meteor client side and server side
var clientServer = startServer(projectDir, clientConfig, 'client');
var serverServer = startServer(projectDir, serverConfig, 'server');
// Slava: load packages preemtively
loadPackages(projectDir, 'os', serverServer);
loadPackages(projectDir, 'web.browser', clientServer);

function startServer(dir, config, type) {
  config = config || {};
  config.dontLoad = config.dontLoad || [];

  var defs = findDefs(dir, config);
  var plugins = loadPlugins(dir, config.plugins);
  var server = new tern.Server({
    getFile: function(name, c) {
      if (config.dontLoad && config.dontLoad.some(function(pat) {return minimatch(name, pat)}))
        c(null, "");
      else
        fs.readFile(path.resolve(dir, name), "utf8", c);
    },
    async: true,
    defs: defs,
    plugins: plugins,
    debug: verbose,
    projectDir: dir,
    dependencyBudget: config.dependencyBudget,
    stripCRs: stripCRs,
    type: type
  });

  var dontLoadExt = ['packages/**', '**/packages/**', '**/.meteor/**'];
  if (config.loadEagerly) config.loadEagerly.forEach(function(pat) {
    glob.sync(pat, { cwd: dir, ignore: config.dontLoad.concat(dontLoadExt) }).forEach(function(file) {
      server.addFile(file);
    });
  });
  return server;
}

function doShutdown() {
  if (persistent) return;
  console.log("Was idle for " + Math.floor(maxIdleTime / 6e4) + " minutes. Shutting down.");
  process.exit();
}

var shutdown = setTimeout(doShutdown, maxIdleTime);

process.stdin.on("end", function() { process.exit(); });
process.stdin.resume();

var httpServer = require("http").createServer(function(req, resp) {
  clearTimeout(shutdown);
  shutdown = setTimeout(doShutdown, maxIdleTime);

  var target = url.parse(req.url, true);
  if (target.pathname == "/ping") return respondSimple(resp, 200, "pong");
  if (target.pathname != "/") return respondSimple(resp, 404, "No service at " + target.pathname);

  if (req.method == "POST") {
    var body = "";
    req.on("data", function (data) { body += data; });
    req.on("end", function() { respond(resp, body); });
  } else if (req.method == "GET") {
    if (target.query.doc) respond(resp, target.query.doc);
    else respondSimple(resp, 400, "Missing query document");
  }
});
httpServer.listen(port, host, function() {
  var port = httpServer.address().port;
  if (!noPortFile) {
    var portFile = path.resolve(projectDir, portFileName);
    fs.writeFileSync(portFile, String(port), "utf8");
    process.on("exit", function() {
      try {
        var cur = Number(fs.readFileSync(portFile, "utf8"));
        if (cur == port) fs.unlinkSync(portFile);
      } catch(e) {}
    });
  }
  process.on("SIGINT", function() { process.exit(); });
  process.on("SIGTERM", function() { process.exit(); });
  console.log("Listening on port " + port);
});

function respondSimple(resp, status, text) {
  resp.writeHead(status, {"content-type": "text/plain"});
  resp.end(text);
  if (verbose) console.log("Response: " + status + " " + text);
}

function respond(resp, doc) {
  try { var doc = JSON.parse(doc); }
  catch(e) { return respondSimple(resp, 400, "JSON parse error: " + e.message); }
  if (verbose) console.log("Request: " + JSON.stringify(doc, null, 2));

  clientServer.request(doc, function(clientErr, clientData) {
    serverServer.request(doc, function(serverErr, serverData) {
      if (clientErr && serverErr) return respondSimple(resp, 400, String(clientErr) + '|' + String(serverErr));

      var data = {};
      if (clientData) data.client = clientData;
      if (serverData) data.server = serverData;

      if (doc && doc.query && doc.query.type !== 'completions') {
        clientData = clientData || {};
        serverData = serverData || {};
        for (var i in clientData)
          if (clientData.hasOwnProperty(i))
            serverData[i] = clientData[i];
        data = serverData;
      }

      if (verbose) console.log("Response: " + JSON.stringify(data, null, 2) + "\n");
      resp.writeHead(200, {"content-type": "application/json"});
      resp.end(JSON.stringify(data));
    });
  });
}
